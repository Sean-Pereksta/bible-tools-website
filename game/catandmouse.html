<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
 <title>üê≠ Cat vs Mouse</title>
<style>
  body {
    font-family: sans-serif;
    text-align: center;
    background: #f4f4f4;
  }

  #grid {
  display: grid;
  justify-content: center;
  grid-template-columns: repeat(30, 20px);
  grid-template-rows: repeat(30, 20px);
  margin: 20px auto;
}


  .cell {
    width: 20px;
    height: 20px;
    text-align: center;
    font-size: 16px;
    position: relative;
    background: #c8f7c5; /* green grass background */
  }

  .name {
    font-size: 10px;
    position: absolute;
    top: -12px;
    left: 0;
    right: 0;
    text-align: center;
  }

  .health-bar {
    position: absolute;
    top: -6px;
    left: 0;
    height: 3px;
    background-color: red;
    border-radius: 1px;
  }

  #info {
    margin-top: 10px;
  }
</style>

<body>
<h1>üê± Cat vs üê≠ Mouse</h1>

<div id="info">
  <p style="margin: 5px 0; font-size: 14px; color: #444;">
  üéÆ Arrow keys to move | A/W/S/D to build | 1/2/3 to select building
</p>
  <p id="status"></p>
  <div id="playerStatus" style="margin-top: 10px;"></div>
  <p>Selected Build: <span id="buildType">None</span></p>
  <p>Cheese Collected: <span id="cheeseCount">0</span></p>
</div>

<div id="grid"></div> <!-- ‚¨ÖÔ∏è Now it's below the UI elements -->


<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, getDocs, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const urlParams = new URLSearchParams(window.location.search);
const gameId = urlParams.get("gameId");
let username = urlParams.get("username");
  username = username.trim().toLowerCase(); // ‚úÖ Normalize once


const gridSize = 30;
const gridElement = document.getElementById("grid");
let grid = [];
let playerPos = { x: 1, y: 1 };
let catPos = { x: 15, y: 15 };
let gameStarted = false;
let selectedBuild = null;
let cheeseCount = 0;
let isAlive = true;
let catHealth = 300;
let players = {};
let isHost = false;
  let canMove = true;
const moveCooldown = 250; // in milliseconds
  let catPower = 0;
  let catMoveInterval = null;





let structureHealth = {}; // key: "x_y", value: health
const fleas = [];
  const rats = []; // üêÄ



for (let y = 0; y < gridSize; y++) {
  grid[y] = [];
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.id = `cell-${x}-${y}`;
    gridElement.appendChild(cell);
    grid[y][x] = "";
  }
}

function renderGrid() {
  const viewSize = 20;
  const halfView = Math.floor(viewSize / 2);
  const viewport = document.getElementById("grid");
  viewport.innerHTML = ""; // Clear old cells

  // Center around player
  const centerX = playerPos.x;
  const centerY = playerPos.y;

  const startX = Math.max(0, centerX - halfView);
  const endX = Math.min(gridSize, centerX + halfView + 1);
  const startY = Math.max(0, centerY - halfView);
  const endY = Math.min(gridSize, centerY + halfView + 1);

  viewport.style.gridTemplateColumns = `repeat(${endX - startX}, 20px)`;
  viewport.style.gridTemplateRows = `repeat(${endY - startY}, 20px)`;

  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      const cell = document.createElement("div");
      cell.id = `cell-${x}-${y}`;
      cell.className = "cell";
      cell.style.background = "#c8f7c5"; // green background
      cell.textContent = grid[y][x];

      viewport.appendChild(cell);
    }
  }

  // üê≠ Players
  for (const name in players) {
    const p = players[name];
    if (p.alive === false) continue;
    if (p.x < startX || p.x >= endX || p.y < startY || p.y >= endY) continue;

    const cell = document.getElementById(`cell-${p.x}-${p.y}`);
    cell.textContent = "üê≠";

    const nameTag = document.createElement("div");
    nameTag.className = "name";
    nameTag.textContent = name;
    cell.appendChild(nameTag);
  }

  // üêû Fleas
  for (let flea of fleas) {
    if (flea.x < startX || flea.x >= endX || flea.y < startY || flea.y >= endY) continue;
    const cell = document.getElementById(`cell-${flea.x}-${flea.y}`);
    cell.textContent = "üêû";
  }

  // üêÄ Rats with health
  for (let rat of rats) {
    if (rat.health <= 0) continue;
    if (rat.x < startX || rat.x >= endX || rat.y < startY || rat.y >= endY) continue;

    const cell = document.getElementById(`cell-${rat.x}-${rat.y}`);
    cell.textContent = "üêÄ";

    const healthTag = document.createElement("div");
    healthTag.className = "name";
    healthTag.style.color = "brown";
    healthTag.textContent = `‚ù§Ô∏è${rat.health}`;
    cell.appendChild(healthTag);
  }

  // üß± Wall and ü™≥ Flea Nest Health Bars
  for (let key in structureHealth) {
    const [xStr, yStr] = key.split("_");
    const x = parseInt(xStr), y = parseInt(yStr);
    if (x < startX || x >= endX || y < startY || y >= endY) continue;

    const symbol = grid[y][x];
    if (symbol === "üß±" || symbol === "ü™≥") {
      const cell = document.getElementById(`cell-${x}-${y}`);
      const bar = document.createElement("div");
      bar.className = "health-bar";
      const hp = structureHealth[key];
      bar.style.width = `${Math.max(10, Math.min(100, hp * 4))}%`;
      bar.style.background = symbol === "üß±" ? "gray" : "purple";
      bar.style.height = "3px";
      bar.style.marginTop = "-10px";
      cell.appendChild(bar);
    }
  }

  // üê± Cat with health and level in one line
  if (catPos.x >= startX && catPos.x < endX && catPos.y >= startY && catPos.y < endY) {
    const catCell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
    catCell.textContent = "üê±";

    const infoTag = document.createElement("div");
    infoTag.className = "name";
    infoTag.style.color = "red";
    infoTag.innerHTML = `‚ù§Ô∏è ${catHealth} ‚ö°Lv.${catPower}`;
    catCell.appendChild(infoTag);
  }

  // üßç Player Status
  const statusDiv = document.getElementById("playerStatus");
  statusDiv.innerHTML = "";
  for (const name in players) {
    const p = players[name];
    const statusSpan = document.createElement("span");
    statusSpan.style.marginRight = "10px";
    statusSpan.style.fontWeight = "bold";
    statusSpan.style.color = (p.alive === false) ? "red" : "green";
    statusSpan.textContent = `${name}: ${p.alive === false ? "DEAD" : "ALIVE"}`;
    statusDiv.appendChild(statusSpan);
  }
}



function movePlayer(dx, dy) {
  if (!gameStarted || !isAlive) return;
  const newX = Math.max(0, Math.min(gridSize - 1, playerPos.x + dx));
  const newY = Math.max(0, Math.min(gridSize - 1, playerPos.y + dy));
  playerPos = { x: newX, y: newY };
  console.log("Trying to move. isAlive =", isAlive);
  savePosition();
  checkCheese();
  renderGrid();
}

function savePosition() {
  const cleanUsername = username.trim().toLowerCase();
  const playerRef = doc(db, `games/${gameId}/players/${cleanUsername}`);

  const payload = {
    x: playerPos.x,
    y: playerPos.y,
    cheese: cheeseCount
  };
  setDoc(playerRef, payload, { merge: true });
}


function startCatBehaviorLoop() {
  if (catMoveInterval) clearInterval(catMoveInterval);

  // üïí Speed = faster interval as power increases
  const speed = Math.max(150, 900 - catPower * 75); // e.g. power 10 = 500ms
  catMoveInterval = setInterval(() => {
    if (gameStarted) catBehavior();
  }, speed);
}


function checkCheese() {
  if (grid[playerPos.y][playerPos.x] === "üßÄ") {
    grid[playerPos.y][playerPos.x] = "";
    cheeseCount += 3;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();
    renderGrid();
  }
}

function placeStructure(dir) {
  if (!gameStarted || !isAlive || !selectedBuild) return;

  // Set cost based on structure type
  let cost = 0;
  if (selectedBuild === 1) cost = 1;
  else if (selectedBuild === 2) cost = 3;
  else if (selectedBuild === 3) cost = 5;

  if (cheeseCount < cost) return;

  let tx = playerPos.x, ty = playerPos.y;
  if (dir === 'w') ty--;
  if (dir === 'a') tx--;
  if (dir === 's') ty++;
  if (dir === 'd') tx++;
  if (tx < 0 || ty < 0 || tx >= gridSize || ty >= gridSize) return;

  let symbol = "";
  let health = 1;

  if (selectedBuild === 1) {
    symbol = "üß±";
    health = 30;
  } else if (selectedBuild === 2) {
    symbol = "üî´";
    health = 5;
  } else if (selectedBuild === 3) {
    symbol = "ü™≥"; // flea nest
    health = 20;
  }

  const key = `${tx}_${ty}`;
  if (grid[ty][tx] === "") {
    grid[ty][tx] = symbol;
    structureHealth[key] = health;
    cheeseCount -= cost;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();

    setDoc(doc(db, `games/${gameId}/structures/${key}`), {
      x: tx,
      y: ty,
      type: symbol,
      health: structureHealth[key]
    });

    renderGrid();
  }
}


function spawnCheese() {
  let spawned = 0;
  let attempts = 0;
  const maxAttempts = 100; // avoid infinite loop if grid is full

  while (spawned < 3 && attempts < maxAttempts) {
    const x = Math.floor(Math.random() * gridSize);
    const y = Math.floor(Math.random() * gridSize);
    if (grid[y][x] === "") {
      grid[y][x] = "üßÄ";
      spawned++;
    }
    attempts++;
  }

  renderGrid();
}


function damageStructure(x, y, damageAmount = (1 + Math.floor(catPower / 3))) {
  const key = `${x}_${y}`;
  if (structureHealth[key] !== undefined) {
    structureHealth[key] -= damageAmount;
    if (structureHealth[key] <= 0) {
      grid[y][x] = "";
      delete structureHealth[key];
      setDoc(doc(db, `games/${gameId}/structures/${key}`), {});
    } else {
      updateDoc(doc(db, `games/${gameId}/structures/${key}`), {
        health: structureHealth[key]
      });
    }
    renderGrid();
  }
}


function turretAttack() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "üî´") {
        let attacked = false;

        // üî´ First check if cat is within 3 tiles
        const dxCat = Math.abs(catPos.x - x);
        const dyCat = Math.abs(catPos.y - y);
        if (dxCat <= 3 && dyCat <= 3) {
          catHealth--;
          updateDoc(doc(db, `games/${gameId}`), {
            cat: { x: catPos.x, y: catPos.y, health: catHealth }
          });
          if (catHealth <= 0) {
            document.getElementById("status").textContent = "üéâ Mice win!";
          }
          attacked = true;
        }

        // üî´ If cat not hit, try to hit one rat
        if (!attacked) {
          for (let rat of rats) {
            if (rat.health <= 0) continue;

            const dxRat = Math.abs(rat.x - x);
            const dyRat = Math.abs(rat.y - y);
            if (dxRat <= 3 && dyRat <= 3) {
              rat.health -= 1;
              console.log(`üí• Turret hit rat at (${rat.x}, ${rat.y}) ‚Üí HP: ${rat.health}`);
              attacked = true;
              break; // stop after hitting one rat
            }
          }
        }
      }
    }
  }

  // üßπ Clean up dead rats
  for (let i = rats.length - 1; i >= 0; i--) {
    if (rats[i].health <= 0) rats.splice(i, 1);
  }

  renderGrid();
}



// üîÅ BFS Pathfinding
function findPath(startX, startY, targetX, targetY) {
  const queue = [[startX, startY, []]];
  const visited = new Set();
  visited.add(`${startX},${startY}`);

  const directions = [
    [1, 0], [-1, 0], [0, 1], [0, -1]
  ];

  while (queue.length > 0) {
    const [x, y, path] = queue.shift();
    if (x === targetX && y === targetY) return path;

    for (const [dx, dy] of directions) {
      const nx = x + dx;
      const ny = y + dy;
      const key = `${nx},${ny}`;

      if (
        nx >= 0 && nx < gridSize &&
        ny >= 0 && ny < gridSize &&
        !visited.has(key) &&
        grid[ny][nx] !== "üß±"
      ) {
        visited.add(key);
        queue.push([nx, ny, [...path, { x: nx, y: ny }]]);
      }
    }
  }

  return null;
}

function catBehavior() {
  console.log("üê± Cat behavior running");

  const aliveMice = Object.entries(players).filter(([_, p]) => p.alive);
  let target = null;
  let path = null;

  // 1Ô∏è‚É£ Mice within 8 tiles
  for (const [_, p] of aliveMice) {
    const dist = Math.abs(p.x - catPos.x) + Math.abs(p.y - catPos.y);
    if (dist <= 6) {
      const pPath = findPath(catPos.x, catPos.y, p.x, p.y);
      if (pPath && (!path || pPath.length < path.length)) {
        target = { x: p.x, y: p.y, type: "mouse" };
        path = pPath;
      }
    }
  }

  // 2Ô∏è‚É£ Structures within 8 tiles (if no mouse)
  if (!target) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const symbol = grid[y][x];
        if (symbol === "üî´" || symbol === "ü™≥") {
          const dist = Math.abs(x - catPos.x) + Math.abs(y - catPos.y);
          if (dist <= 9) {
            const sPath = findPath(catPos.x, catPos.y, x, y);
            if (sPath && (!path || sPath.length < path.length)) {
              target = { x, y, type: "structure" };
              path = sPath;
            }
          }
        }
      }
    }
  }

  // 3Ô∏è‚É£ Fallback: Nearest anything (mouse, turret, flea nest, wall)
  if (!target) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const symbol = grid[y][x];
        if (symbol === "üß±" || symbol === "üî´" || symbol === "ü™≥") {
          const fPath = findPath(catPos.x, catPos.y, x, y);
          if (fPath && (!path || fPath.length < path.length)) {
            target = { x, y, type: "fallback" };
            path = fPath;
          }
        }
      }
    }

    for (const [_, p] of aliveMice) {
      const fPath = findPath(catPos.x, catPos.y, p.x, p.y);
      if (fPath && (!path || fPath.length < path.length)) {
        target = { x: p.x, y: p.y, type: "fallbackMouse" };
        path = fPath;
      }
    }
  }

  // üêæ Move
  if (target && path && path.length > 1) {
    const next = path[1];
    catPos.x = next.x;
    catPos.y = next.y;
    console.log(`‚úÖ Cat moved to (${catPos.x}, ${catPos.y})`);
  }

  // üí• Attack one adjacent structure only
  let attacked = false;
 for (let dy = -1; dy <= 1 && !attacked; dy++) {
  for (let dx = -1; dx <= 1 && !attacked; dx++) {
    const tx = catPos.x + dx;
    const ty = catPos.y + dy;
    if (
      tx >= 0 && tx < gridSize &&
      ty >= 0 && ty < gridSize &&
      (grid[ty][tx] === "üß±" || grid[ty][tx] === "üî´" || grid[ty][tx] === "ü™≥")
    ) {
      damageStructure(tx, ty);
      attacked = true;
    }
  }
}


  // üíÄ Kill any players on the cat‚Äôs tile
  for (const [name, p] of Object.entries(players)) {
    if ((p.alive ?? true) && catPos.x === p.x && catPos.y === p.y) {
      console.log(`üíÄ Cat killed ${name}`);
      updateDoc(doc(db, `games/${gameId}/players/${name}`), { alive: false });

      if (name === username) {
        isAlive = false;
        document.getElementById("status").textContent = "üíÄ You are dead!";
      }
    }
  }

  updateDoc(doc(db, `games/${gameId}`), {
    cat: { x: catPos.x, y: catPos.y, health: catHealth }
  });

  renderGrid();
}



async function listenToGame() {

  onSnapshot(collection(db, `games/${gameId}/structures`), (snap) => {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (grid[y][x] === "üß±" || grid[y][x] === "üî´") grid[y][x] = "";
      }
    }
    structureHealth = {};
    snap.forEach((docSnap) => {
      const { x, y, type, health } = docSnap.data();
      if (x !== undefined && y !== undefined && type) {
        grid[y][x] = type;
        structureHealth[`${x}_${y}`] = health;
      }
    });
    renderGrid();
  });

  onSnapshot(doc(db, `games/${gameId}`), (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();

      if (isHost && (!data.cat || typeof data.cat.x !== "number" || typeof data.cat.y !== "number")) {
        const initialCat = {
          x: gridSize - 1,
          y: gridSize - 1,
          health: 300
        };
        updateDoc(doc(db, `games/${gameId}`), { cat: initialCat });
      }

      const cat = data.cat || {};
      catPower = data.catPower || 0;
      catPos = { x: cat.x || 15, y: cat.y || 15 };
      catHealth = cat.health || 100;
      renderGrid();
    }
  });

  onSnapshot(collection(db, `games/${gameId}/players`), (snap) => {
  players = {};
  snap.forEach((docSnap) => {
    players[docSnap.id.toLowerCase()] = docSnap.data(); // ‚úÖ force lowercase key
  });
  renderGrid();
});

  const playerRef = doc(db, `games/${gameId}/players/${username}`);
  await setDoc(playerRef, {
  x: playerPos.x,
  y: playerPos.y,
  cheese: 0,
  alive: true,
  displayName: urlParams.get("username").trim()
}, { merge: true });


  onSnapshot(playerRef, (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      playerPos = { x: data.x, y: data.y };
      isAlive = data.alive !== false;
      cheeseCount = data.cheese || 0;
      document.getElementById("cheeseCount").textContent = cheeseCount;
      console.log("üî• Player isAlive = ", isAlive);
      document.getElementById("status").textContent = isAlive
        ? ""
        : "üíÄ You are dead!";
      renderGrid();
    }
  });
}
window.addEventListener("keydown", (e) => {
  if (!canMove || !isAlive) return; // ‚õî Block input if dead

  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) e.preventDefault();

  switch (e.key) {
    case "ArrowUp": movePlayer(0, -1); break;
    case "ArrowDown": movePlayer(0, 1); break;
    case "ArrowLeft": movePlayer(-1, 0); break;
    case "ArrowRight": movePlayer(1, 0); break;
    case "1":
  selectedBuild = 1;
  document.getElementById("buildType").textContent = "Wall üß± (Cost: 1)";
  break;
case "2":
  selectedBuild = 2;
  document.getElementById("buildType").textContent = "Turret üî´ (Cost: 3)";
  break;
case "3":
  selectedBuild = 3;
  document.getElementById("buildType").textContent = "Flea Nest ü™≥ (Cost: 5)";
  break;


    case "w":
    case "a":
    case "s":
    case "d":
      placeStructure(e.key);
      break;
  }

  canMove = false;
  setTimeout(() => canMove = true, moveCooldown);
});



// After listenToGame():
listenToGame();
gameStarted = true;

// Place initial structures
grid[24][15] = "üß±";
grid[25][14] = "üß±";
grid[25][16] = "üß±";
renderGrid();

// Start cheese spawn and turret attack globally
setInterval(spawnCheese, 10000);
setInterval(turretAttack, 1000);

  // üêÄ Summon Rats every 2 minutes based on catPower
setInterval(() => {
  if (!gameStarted || catPower <= 0) return;

  let spawned = 0;
  const maxRats = catPower;
  const offsets = [
    { x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 0 },
    { x: 0, y: 1 }, { x: 0, y: -1 }, { x: 1, y: 1 },
    { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 },
    { x: 2, y: 0 }, { x: 0, y: 2 }, { x: -2, y: 0 }, { x: 0, y: -2 }
  ]; // Spacing options

  for (let i = 0; i < offsets.length && spawned < maxRats; i++) {
    const ox = catPos.x + offsets[i].x;
    const oy = catPos.y + offsets[i].y;

    if (
      ox >= 0 && ox < gridSize &&
      oy >= 0 && oy < gridSize &&
      !rats.some(r => r.x === ox && r.y === oy) // no overlap
    ) {
      rats.push({ x: ox, y: oy, health: 5 });
      spawned++;
    }
  }

  console.log(`üêÄ ${spawned} rats spawned (Power Level: ${catPower})`);
}, 60000);

setInterval(() => {
  for (let rat of rats) {
    if (rat.health <= 0) continue;

    let closestTarget = null;
    let minDist = Infinity;

    // üß† Step 1: Find nearest target (mouse or structure)
    for (const [name, p] of Object.entries(players)) {
      if (p.alive !== false) {
        const dist = Math.abs(p.x - rat.x) + Math.abs(p.y - rat.y);
        if (dist < minDist) {
          minDist = dist;
          closestTarget = { x: p.x, y: p.y, type: "mouse", name };
        }
      }
    }

    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (["üß±", "üî´", "ü™≥"].includes(grid[y][x])) {
          const dist = Math.abs(x - rat.x) + Math.abs(y - rat.y);
          if (dist < minDist) {
            minDist = dist;
            closestTarget = { x, y, type: "structure" };
          }
        }
      }
    }

    // üß† Step 2: Basic targeting movement
    let dx = 0, dy = 0;
    if (closestTarget) {
      const dxt = closestTarget.x - rat.x;
      const dyt = closestTarget.y - rat.y;

      if (Math.abs(dxt) > Math.abs(dyt)) {
        dx = Math.sign(dxt);
      } else {
        dy = Math.sign(dyt);
      }
    }

    // üß† Step 3: Cohesion - move toward average nearby rat position
    let avgX = 0, avgY = 0, nearby = 0;
    for (let other of rats) {
      if (other !== rat && other.health > 0) {
        const dist = Math.abs(other.x - rat.x) + Math.abs(other.y - rat.y);
        if (dist <= 3) {
          avgX += other.x;
          avgY += other.y;
          nearby++;
        }
      }
    }

    if (nearby > 0) {
      avgX = avgX / nearby;
      avgY = avgY / nearby;
      const cohesionDx = Math.sign(avgX - rat.x);
      const cohesionDy = Math.sign(avgY - rat.y);

      // Mix target chase and cohesion
      dx += cohesionDx * 0.5;
      dy += cohesionDy * 0.5;
    }

    // üß† Step 4: Separation - avoid other rats on same spot
    const occupied = rats.some(other => other !== rat && other.x === rat.x + dx && other.y === rat.y + dy);
    if (occupied) {
      dx = 0;
      dy = 0;
    }

    // Move if valid
    const newX = rat.x + Math.sign(dx);
    const newY = rat.y + Math.sign(dy);
    if (
      newX >= 0 && newX < gridSize &&
      newY >= 0 && newY < gridSize &&
      grid[newY][newX] !== "üß±"
    ) {
      rat.x = newX;
      rat.y = newY;
    }

    // Attack
    if (closestTarget && rat.x === closestTarget.x && rat.y === closestTarget.y) {
      if (closestTarget.type === "structure") {
        damageStructure(rat.x, rat.y, 1);
      } else if (closestTarget.type === "mouse") {
        const playerRef = doc(db, `games/${gameId}/players/${closestTarget.name}`);
        updateDoc(playerRef, { alive: false });
        if (closestTarget.name === username) {
          isAlive = false;
          document.getElementById("status").textContent = "üíÄ You are dead!";
        }
      }
    }
  }

  // Cleanup
  for (let i = rats.length - 1; i >= 0; i--) {
    if (rats[i].health <= 0) rats.splice(i, 1);
  }

  renderGrid();
}, 500);


// ü™≥ Flea Spawning Every 5 Seconds from Nests
setInterval(() => {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "ü™≥") {
        fleas.push({ x, y, lifetime: 15 }); // spawn flea
      }
    }
  }
}, 4000);

setInterval(() => {
  for (let flea of fleas) {
    let target = null;
    let minDist = Infinity;

    // Check distance to cat
    const distToCat = Math.abs(catPos.x - flea.x) + Math.abs(catPos.y - flea.y);
    if (distToCat < minDist) {
      minDist = distToCat;
      target = { x: catPos.x, y: catPos.y, type: "cat" };
    }

    // Check distances to all rats
    for (let rat of rats) {
      const dist = Math.abs(rat.x - flea.x) + Math.abs(rat.y - flea.y);
      if (dist < minDist && rat.health > 0) {
        minDist = dist;
        target = { x: rat.x, y: rat.y, type: "rat", rat };
      }
    }

    // Move toward the closest target
    if (target) {
      let dx = 0, dy = 0;
      const xDiff = target.x - flea.x;
      const yDiff = target.y - flea.y;

      if (Math.abs(xDiff) > Math.abs(yDiff)) {
        dx = Math.sign(xDiff);
      } else {
        dy = Math.sign(yDiff);
      }

      const newX = flea.x + dx;
      const newY = flea.y + dy;

      if (
  newX >= 0 && newX < gridSize &&
  newY >= 0 && newY < gridSize
) {
  flea.x = newX;
  flea.y = newY;
}


      // üêû Flea attack logic
      if (flea.x === target.x && flea.y === target.y) {
        if (target.type === "cat") {
          catHealth -= 1;
          flea.lifetime = 0;

          updateDoc(doc(db, `games/${gameId}`), {
            cat: { ...catPos, health: catHealth }
          });

          if (catHealth <= 0) {
            document.getElementById("status").textContent = "üéâ Mice win!";
          }
        } else if (target.type === "rat" && target.rat) {
          target.rat.health = 0;
          flea.lifetime = 0;
        }
      }
    }

    // üïì Decrement flea lifetime
    flea.lifetime--;
  }

  // üßπ Remove expired fleas
  for (let i = fleas.length - 1; i >= 0; i--) {
    if (fleas[i].lifetime <= 0) fleas.splice(i, 1);
  }

  renderGrid();
}, 400);





// ‚úÖ Wrap host logic in an async function
(async () => {
  const cleanUsername = username.trim().toLowerCase();
  const gameRef = doc(db, `games/${gameId}`);

  const docSnap = await getDoc(gameRef);
  const data = docSnap.exists() ? docSnap.data() : {};
  if (!data.host) {
    await setDoc(gameRef, { host: cleanUsername }, { merge: true });
  }

  const updatedSnap = await getDoc(gameRef);
  const host = updatedSnap.data().host;

 if (host === cleanUsername) {
  isHost = true;
  console.log("üëë You are host. Starting cat AI.");
  gameStarted = true;

  // Start initial cat behavior loop
  startCatBehaviorLoop();

  // Increase power every 30 seconds
  setInterval(async () => {
    if (gameStarted) {
      catPower++;
      catHealth += 5;
      console.log(`üîã Cat power increased to ${catPower}`);

      await updateDoc(doc(db, `games/${gameId}`), {
        catPower,
        cat: { ...catPos, health: catHealth }
      });

      // Restart loop with updated speed
      startCatBehaviorLoop();
    }
  }, 20000);
}
})();



</script>
</body>
</html>

