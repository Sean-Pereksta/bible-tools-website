<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üê≠ Cat vs Mouse</title>
  <style>
    body { font-family: sans-serif; text-align: center; background: #f4f4f4; }
    #grid { display: grid; grid-template-columns: repeat(30, 20px); grid-template-rows: repeat(30, 20px); margin: 20px auto; }
    .cell { width: 20px; height: 20px; text-align: center; font-size: 16px; position: relative; }
    .name { font-size: 10px; position: absolute; top: -12px; left: 0; right: 0; text-align: center; }
    #info { margin-top: 10px; }
  </style>
</head>
<body>
<h1>üê± Cat vs üê≠ Mouse</h1>
<div id="grid"></div>
<div id="info">
  <p id="status"></p>
  <p>Selected Build: <span id="buildType">None</span></p>
  <p>Cheese Collected: <span id="cheeseCount">0</span></p>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, getDocs, increment } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyB7twY7z31ucB6pGA8JC_HrVMZhA8lNaJA",
  authDomain: "bible-game-246c0.firebaseapp.com",
  projectId: "bible-game-246c0"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const urlParams = new URLSearchParams(window.location.search);
const gameId = urlParams.get("gameId");
const username = urlParams.get("username");

const gridSize = 30;
const gridElement = document.getElementById("grid");
let grid = [];
let playerPos = { x: 1, y: 1 };
let catPos = { x: 15, y: 15 };
let gameStarted = false;
let selectedBuild = null;
let cheeseCount = 0;
let isAlive = true;
let catHealth = 100;
let players = {};

let structureHealth = {}; // key: "x_y", value: health

for (let y = 0; y < gridSize; y++) {
  grid[y] = [];
  for (let x = 0; x < gridSize; x++) {
    const cell = document.createElement("div");
    cell.className = "cell";
    cell.id = `cell-${x}-${y}`;
    gridElement.appendChild(cell);
    grid[y][x] = "";
  }
}

function renderGrid() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const cell = document.getElementById(`cell-${x}-${y}`);
      cell.textContent = grid[y][x];
      cell.innerHTML = grid[y][x];
    }
  }
  for (const name in players) {
    const p = players[name];
    if (p.alive) {
      const cell = document.getElementById(`cell-${p.x}-${p.y}`);
      if (name === username) {
        cell.textContent = "üê≠";
      } else {
        cell.textContent = "üê≠";
      }
      const nameTag = document.createElement("div");
      nameTag.className = "name";
      nameTag.textContent = name;
      cell.appendChild(nameTag);
    }
  }
  const catCell = document.getElementById(`cell-${catPos.x}-${catPos.y}`);
  catCell.textContent = "üê±";
}

function movePlayer(dx, dy) {
  if (!gameStarted || !isAlive) return;
  const newX = Math.max(0, Math.min(gridSize - 1, playerPos.x + dx));
  const newY = Math.max(0, Math.min(gridSize - 1, playerPos.y + dy));
  playerPos = { x: newX, y: newY };
  savePosition();
  checkCheese();
  checkReviveFlag();
  renderGrid();
}

function savePosition() {
  const playerRef = doc(db, `games/${gameId}/players/${username}`);
  setDoc(playerRef, { x: playerPos.x, y: playerPos.y, alive: true, cheese: cheeseCount }, { merge: true });
}

function checkCheese() {
  if (grid[playerPos.y][playerPos.x] === "üßÄ") {
    grid[playerPos.y][playerPos.x] = "";
    cheeseCount++;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    renderGrid();
  }
}

function placeStructure(dir) {
  if (!gameStarted || !selectedBuild || cheeseCount < selectedBuild) return;
  let tx = playerPos.x, ty = playerPos.y;
  if (dir === 'w') ty--;
  if (dir === 'a') tx--;
  if (dir === 's') ty++;
  if (dir === 'd') tx++;
  if (tx < 0 || ty < 0 || tx >= gridSize || ty >= gridSize) return;
  const symbol = selectedBuild === 1 ? "üß±" : selectedBuild === 2 ? "üî´" : "";
  const key = `${tx}_${ty}`;
  if (grid[ty][tx] === "") {
    grid[ty][tx] = symbol;
    structureHealth[key] = selectedBuild === 1 ? 2 : 1;
    cheeseCount -= selectedBuild;
    document.getElementById("cheeseCount").textContent = cheeseCount;
    savePosition();
    setDoc(doc(db, `games/${gameId}/structures/${key}`), {
      x: tx,
      y: ty,
      type: symbol,
      health: structureHealth[key]
    });
    renderGrid();
  }
}

function spawnCheese() {
  const x = Math.floor(Math.random() * gridSize);
  const y = Math.floor(Math.random() * gridSize);
  if (grid[y][x] === "") {
    grid[y][x] = "üßÄ";
    renderGrid();
  }
}

function damageStructure(x, y) {
  const key = `${x}_${y}`;
  if (structureHealth[key] !== undefined) {
    structureHealth[key]--;
    if (structureHealth[key] <= 0) {
      grid[y][x] = "";
      delete structureHealth[key];
      setDoc(doc(db, `games/${gameId}/structures/${key}`), {}); // clears the data in Firestore
    } else {
      updateDoc(doc(db, `games/${gameId}/structures/${key}`), {
        health: structureHealth[key]
      });
    }
    renderGrid();
  }
}

function turretAttack() {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      if (grid[y][x] === "üî´") {
        const dx = Math.abs(catPos.x - x);
        const dy = Math.abs(catPos.y - y);
        if (dx <= 3 && dy <= 3) {
          catHealth--;
          updateDoc(doc(db, `games/${gameId}`), { cat: { x: catPos.x, y: catPos.y, health: catHealth } });
          if (catHealth <= 0) {
            document.getElementById("status").textContent = "üéâ Mice win!";
          }
        }
      }
    }
  }
}

function catBehavior() {
  const nearbyMice = Object.entries(players).filter(([_, p]) => p.alive && Math.abs(p.x - catPos.x) <= 3 && Math.abs(p.y - catPos.y) <= 3);
  if (nearbyMice.length > 0) {
    const target = nearbyMice[0][1];
    const dx = Math.sign(target.x - catPos.x);
    const dy = Math.sign(target.y - catPos.y);
    const nextX = catPos.x + dx;
    const nextY = catPos.y + dy;

    // Block cat from walking through walls
    if (
      nextX >= 0 && nextX < gridSize &&
      nextY >= 0 && nextY < gridSize &&
      grid[nextY][nextX] !== "üß±"
    ) {
      catPos.x = nextX;
      catPos.y = nextY;
    }
  }
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const tx = catPos.x + dx;
      const ty = catPos.y + dy;
      if (tx >= 0 && tx < gridSize && ty >= 0 && ty < gridSize) {
        if (grid[ty][tx] === "üß±" || grid[ty][tx] === "üî´") {
          damageStructure(tx, ty);
        }
      }
    }
  }
  updateDoc(doc(db, `games/${gameId}`), { cat: { x: catPos.x, y: catPos.y, health: catHealth } });
  renderGrid();
}

function checkReviveFlag() {
  if (playerPos.x === 15 && playerPos.y === 15 && !isAlive) {
    isAlive = true;
    savePosition();
    document.getElementById("status").textContent = "";
    renderGrid();
  }
}

function listenToGame() {
  onSnapshot(collection(db, `games/${gameId}/structures`), (snap) => {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (grid[y][x] === "üß±" || grid[y][x] === "üî´") grid[y][x] = "";
      }
    }
    structureHealth = {};
    snap.forEach((docSnap) => {
      const { x, y, type, health } = docSnap.data();
      if (x !== undefined && y !== undefined && type) {
        grid[y][x] = type;
        structureHealth[`${x}_${y}`] = health;
      }
    });
    renderGrid();
  });
  onSnapshot(doc(db, `games/${gameId}`), (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      const cat = data.cat || {};
      catPos = { x: cat.x || 15, y: cat.y || 15 };
      catHealth = cat.health || 100;
      renderGrid();
    }
  });

  onSnapshot(collection(db, `games/${gameId}/players`), (snap) => {
    players = {};
    snap.forEach((docSnap) => {
      players[docSnap.id] = docSnap.data();
    });
    renderGrid();
  });

  const playerRef = doc(db, `games/${gameId}/players/${username}`);
  onSnapshot(playerRef, (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      playerPos = { x: data.x, y: data.y };
      isAlive = data.alive;
      cheeseCount = data.cheese || 0;
      document.getElementById("cheeseCount").textContent = cheeseCount;
      if (!data.alive) {
        document.getElementById("status").textContent = "üíÄ You are dead!";
      } else {
        document.getElementById("status").textContent = "";
      }
    }
  });
}

function startCountdown() {
  let seconds = 30;
  const status = document.getElementById("status");
  status.textContent = `Game starts in ${seconds}...`;
  const interval = setInterval(() => {
    seconds--;
    status.textContent = `Game starts in ${seconds}...`;
    if (seconds <= 0) {
      clearInterval(interval);
      gameStarted = true;
      status.textContent = "Go!";
      setInterval(spawnCheese, 30000);
      setInterval(turretAttack, 1000);
      if (username === "host") setInterval(catBehavior, 1000);
    }
  }, 1000);
}

window.addEventListener("keydown", (e) => {
  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) e.preventDefault();
  switch (e.key) {
    case "ArrowUp": movePlayer(0, -1); break;
    case "ArrowDown": movePlayer(0, 1); break;
    case "ArrowLeft": movePlayer(-1, 0); break;
    case "ArrowRight": movePlayer(1, 0); break;
    case "1": selectedBuild = 1; document.getElementById("buildType").textContent = "Wall üß±"; break;
    case "2": selectedBuild = 2; document.getElementById("buildType").textContent = "Turret üî´"; break;
    case "w": case "a": case "s": case "d": placeStructure(e.key); break;
  }
});

renderGrid();
savePosition();
listenToGame();
startCountdown();
</script>
</body>
</html>

